// *Списки*

val numerals = List(1, 2, 3, 4)


// *Наборы (Sets)*
// Наборы не содержат одинаковых элементов

Set(1, 1, 2)


// *Кортеж*
// Кортеж объединяет простые логические элементы
// коллекции без использования классов.

val hostPort = ("localhost", 80)

// В отличие от case классов, у него нет именованных
// функций доступа, вместо этого у него есть
// функции доступа, которые носят названия по
// номеру позиции элемента кортежа и они
// нумеруются с 1, а не с 0.

hostPort._1
hostPort._2

// Кортежи прекрасно могут использоваться
// вместе с сопоставлением с образцом.

hostPort match {
  case ("localhost", port) => "hey we are in dev env"
  case (host, port) => "seems like prod"
}

// Кортежи имеет специальный “соус”, который позволяет
// сделать Кортеж 2 значений: ->

1 -> 2

// Смотрите также: В Effective Scala описывается
// разрушение связей (“распаковка” кортежа).


// *Карты*
// Они могут содержать в себе основные типы данных.

Map(1 -> 2)
Map("foo" -> "bar")

// Выглядит словно это особый синтаксис, но вспомните
// наше обсуждение в разделе Кортеж, что с
// помощью -> можно создавать Кортежи.

// Map() тоже использует синтаксис, который мы
// изучили ранее на Уроке №1: Map(1 -> "one", 2 -> "two"),
// который раскрывается в Map((1, "one"), (2, "two")),
// где первый элемент является ключом, а вторым
// элементом является некое значение.

// Карты внутри себя могут содержать другие Карты
// или даже функции.

Map(1 -> Map("foo" -> "bar"))
Map("timesTwo" -> { timesTwo(_) })


// *Опция*
// Опция представляет собой контейнер, который хранит
// какое-то значение или не хранит ничего совсем.

// Основной интерфейс Опции выглядит следующим образом:

// trait Option[T] { def isDefined: Boolean def get: T def getOrElse(t: T): T }

// Опция сам по себе это обобщенный тип и он
// имеет два подкласса: Some[T] и None

// Давайте взглянем на пример того, как Опция может
// использоваться:

//Map.get использует Option для возврата собственных
// значений. Опция говорит вам, что метод может не
// вернуть того значения, которое мы запросили.

val numbers = Map("one" -> 1, "two" -> 2)
numbers.get("two")
numbers.get("three")

// Теперь наши данные отлавливаются с помощью Option.
// Как мы можем это использовать?

// Первое, что приходит на ум, это использовать условие,
// опираясь на метод isDefined.

// Мы хотим умножить число на 2 или возвратить 0.

val r1: Option[Int] = Some(21)
val r2 = if (r1.isDefined) { r1.get * 2 } else { 0 }

// Мы предполагаем, что вы будете использовать getOrElse
// или сопоставление с образцом для результата.

// getOrElse дает вам легкий способ объявить стандартное
// значение.

val r3 = r1.getOrElse(0) * 2

// Option прекрасно работает вместе с сопоставлением
// с образцом.

val r4 = r1 match {
  case Some(n) => n * 2
  case None => 0
}

// Смотрите также: В Effective Scala описываются Опции.



// *Функциональные комбинаторы*

// Комбинаторы называются так потому, что они созданы,
// чтобы объединять результаты. Результат одной функции
// часто используется в качестве входных данных для другой.

// Наиболее распространенным способом, является
// использование их со стандартными структурами данных.

// *map*
// Применяет функцию к каждому элементу из списка,
// возвращается список с тем же числом элементов.

numerals.map((i: Int) => i * 2)

// или передается частично вызываемая функция

def timesTwo(i: Int): Int = i * 2
numerals.map(timesTwo _)

// *foreach*
// foreach похож на map, но ничего не возвращает.
// foreach используется для создания побочных эффектов.

numerals.foreach((i: Int) => i * 2)

// Он ничего не возвращает.

// Вы можете попробовать сохранить результат в
// переменную, но она будет иметь тип Unit
// (другими словами void)

val doubled = numerals.foreach((i: Int) => i * 2)

// *filter*
// Данный комбинатор удаляет любой элемент, если функция,
// применяемая к этому элементу, возвращает ложь.
// Функции, которые возвращают Boolean, часто
// называются функциями-предикатами

numerals.filter((i: Int) => i % 2 == 0)

def isEven(i: Int): Boolean = i % 2 == 0

numerals.filter(isEven _)

// *zip*
// zip объединяет содержимое двух списков в один
// парный список.

List(1, 2, 3).zip(List("a", "b", "c"))

// *partition*
// partition разделяет список, в зависимости от
// результата, который возвращает функция-предикат.

List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).partition(_ % 2 == 0)

// *find*
// find возвращает первый элемент коллекции, который
// удовлетворяет функции-предикату.

numerals.find((i: Int) => i > 5)

// *drop и dropWhile*
// drop удаляет первый элемент с индексом i

numerals.drop(5)

// dropWhile удаляет первый элемент, который не
// удовлетворяет функции-предикату. Например, если мы
// применим dropWhile к нечетным числам из нашего списка,
// то 1 будет удалена (но не 3, которая стоит за 2).

numerals.dropWhile(_ % 2 != 0)

// *foldLeft*

numerals.foldLeft(0)((m: Int, n: Int) => m + n)

// 0 – это начальное значение (Не забывайте, что мы
// используем числа из List[Int]), где m
// работает как аккумулятор.

// Взгляните сами:

numerals.foldLeft(0) { (m: Int, n: Int) => println("m: " + m + " n: " + n); m + n }

// *foldRight*
// Этот комбинатор похож на foldLeft, за исключением
// того, что он работает с противоположной стороны.

numerals.foldRight(0) { (m: Int, n: Int) => println("m: " + m + " n: " + n); m + n }

// *flatten*
// flatten сжимает вложенные структуры.

List(List(1, 2), List(3, 4)).flatten

// *flatMap*
// flatMap это часто используемый комбинатор, который
// объединяет map и flatten. flatMap берет функцию,
// которая работает с вложенными списками и объединяет
// результаты.

val nestedNumbers = List(List(1, 2), List(3, 4))
nestedNumbers.flatMap(x => x.map(_ * 2))

// Думайте об этом, как о коротком способе использования
// map, а затем применения flatten к результату [dra1n:
// весьмя ограниченный способ восприятия]:

nestedNumbers.map((x: List[Int]) => x.map(_ * 2)).flatten

// в этом примере вызывается map, а позднее flatten,
// как пример “комбинаторной” природы этих функций.

// Смотрите также: В Effective Scala описывается flatMap.



// *Обобщенные функциональные комбинаторы*
// Теперь мы узнали о множестве функции для работы с
// коллекциями.

// Что нам может понадобиться, чтобы иметь возможность
// написать свои функциональные комбинаторы?

// Интересно, что каждый функциональный комбинатор
// показанный выше, может быть написан поверх fold.
// Рассмотрим несколько примеров.

def ourMap(numbers: List[Int], fn: Int => Int): List[Int] = {
  numbers.foldRight(List[Int]()) { (x: Int, xs: List[Int]) =>
    fn(x) :: xs
  }
}

ourMap(numerals, timesTwo(_))

// Почему именно List[Int]()? Scala не достаточно умна,
// чтобы реализовать пустой список, для хранения
// целочисленных значений.


// *А как же Map?*
// Все функциональные комбинаторы прекрасно работают и
// с Картами. Карты можно рассматривать как список пар,
// так что функции, которые вы пишете работают с парами
// ключей и значений Карты.

val extensions = Map("steve" -> 100, "bob" -> 101, "joe" -> 201)

// теперь выберем каждую запись, у которой
// телефонный код меньше 200.

extensions.filter((namePhone: (String, Int)) => namePhone._2 < 200)

// Т.к. в результате вы получаете кортеж, то вам
// приходиться тащить ключи и значения с их позиционными
// функциями доступа. Да уж!

// К счастью, мы можем использовать сопоставление
// с образцом, чтобы извлечь ключ и значение.

extensions.filter({case (name, extension) => extension < 200})