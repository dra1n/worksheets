// *Выражения*
1 + 1
// res0 – автоматически создаваемое имя для переменной,
// которое интерпретатор дает результату вашего
// выражения. Переменная имеет тип Int и содержит
// целочисленное значение 2.
// Все (ну, почти) в Scala – выражение.
// *Константы*
// Вы можете присвоить собственное имя результату
// выражения.
val two = 1 + 1
// *Переменные*
// Если вам нужно изменить значение константы, вы
// должны использовать ключевое слово var
var name = "steve"
name = "marius"
// *Функции*
// Вы можете создать функцию с помощью ключевого слова def.
def addOne(m: Int): Int = m + 1
// В Scala, вам нужно точно указывать тип,
// который принимает переменная в параметрах функции.
// К счастью, интерпретатор возвращает используемый
// функцией тип обратно.
addOne(2)

// Вы можете опускать скобки при использовании функций,
// если они не имеют аргументов.

def three() = 1 + 2
three()
three


// *Анонимные функции*
// Вы можете создавать анонимные функции.

val f = (x: Int) => x + 1
f(1)

// Вы можете передавать анонимные функции как
// параметры или сохранять их в переменных.

val addOne1 = (x: Int) => x + 1
addOne(1)

// Если ваша функция состоит из множества выражений,
// вы можете использовать фигурные скобки {},
// чтобы обезопасить себя.

def timesTwo(i: Int): Int = {
  println("hello world")
  i * 2
}

// Тоже самое верно и для анонимной функции

{ i: Int =>
  println("hello world")
  i * 2
}

// Вы часто будете видеть подобный синтаксис
// при передачи анонимной функции в качестве параметра.


// *Частичный вызов функций*
// Вы можете использовать частичный вызов функций,
// обозначаемый знаком нижнего подчеркивания(_),
// этот знак позже будет подменен вызовом функции.

def adder(m: Int, n: Int) = m + n

val add2 = adder(2, _:Int)

add2(3)

// Вы можете использовать частичный вызов функций
// с любым аргументом из списка аргументов,
// а не только с последним из них, как в примере.


// *Каррирование функций*
// Иногда требуется передача каких-то аргументов в
// вашу функцию прямо сейчас, а других через
// некоторое время.
//
// Ниже пример функции, которая позволяет умножать
// два числа. В одном месте вызова функции вы решите,
// какой из аргументов будет множителем, а позднее
// вызывая функцию, вы сможете установить множимое.

def multiply(m: Int)(n: Int): Int = m * n

// Вы можете вызвать функцию напрямую с двумя аргументами.

multiply(2)(3)

// Вы можете передать первый аргумент, а второй
// аргумент объявить как частично вызываемый.

val timesTwo1 = multiply(2) _

timesTwo1(3)

// Вы можете взять любую функцию с множеством
// аргументов и произвести ее каррирование.
// Давайте попробуем использовать функцию,
// которую рассматривали раньше, например adder

(adder _).curried


// *Использование переменного количества аргументов*
// Существует специальный синтаксис для методов,
// которые могут принимать параметры одного и
// того же типа.

def capitalizeAll(args: String*) = {
  args.map { arg =>
    arg.capitalize
  }
}


// *Классы*
class Calculator {
  val brand: String = "HP"
  def add(m: Int, n: Int): Int = m + n
}

// Здесь мы объявили класс Calculator

val calc = new Calculator
calc.add(1, 2)
calc.brand

// В примере объявляется метод и поле с ключевым
// словом val. Методы – это функции, которые имеют
// доступ к внутренним сущностям класса.


// *Конструктор*
// Конструкторы не являются специальными методами,
// их код находится в классе за пределами определения
// метода. Давайте расширим наш пример с калькулятором.
// Будем принимать аргумент конструктора и использовать
// его для инициализации внутреннего состояния.

class Calculator1(brand: String) {
  /**
   * Конструктор.
   */
  val color: String = if (brand == "TI") {
    "blue"
  } else if (brand == "HP") {
    "black"
  } else {
    "white"
  }

  // Метод экземпляра класса.
  def add(m: Int, n: Int): Int = m + n
}

// Обратите внимание на два различных способа
// написания комментариев.


// *Выражения*
// Наш пример с калькулятором дает хороший пример
// того, как Scala ориентирован на выражения
// (expression-oriented). Значение переменной color
// было присвоено благодаря if/else выражению. Scala
// сильно ориентирован на выражения: большинство
// вещей делается с помощью выражений, а не утверждений.



// *Наследование*

class ScientificCalculator(brand: String) extends Calculator1(brand) {
  def log(m: Double, base: Double) = math.log(m) / math.log(base)
}

// Смотрите также: В Effective Scala указывается на то,
// что лучше использовать Псевдонимы типов вместо
// extends, особенно если подкласс практически
// ничем не отличается от суперкласса. В “Туре по языку Scala”
// вы найдете более подробное описание Подклассов.


// *Перегрузка методов*

class EvenMoreScientificCalculator(brand: String) extends ScientificCalculator(brand) {
  def log(m: Int): Double = log(m, math.exp(1))
}

// *Трейты*

// Трейты – это коллекция полей и методов, которые
// вы можете расширить или примешать к вашему классу.

trait Car {
  val brand: String
}

class BMW extends Car {
  val brand = "BMW"
}

// Смотрите также: В Effective Scala есть описание Трейтов.



// *Типы*
// Ранее вы могли видеть, что мы определили функцию, принимающая
// тип Int, который является одним из видов Number. Функция может
// быть объявлена как обобщенная (generic) и после этого может
// работать с любым типом. Когда объявлена такая функция, вы
// увидите

// параметр-тип

// размещенный внутри квадратных скобок:
// Вы можете думать о них, как о множестве параметров-типов.
// Рассмотрим пример трейта Кэш (Cache), который принимает
// параметры-типы (K, V) для ключей и их значений.

trait Cache[K, V] {
  def get(key: K): V
  def put(key: K, value: V)
  def delete(key: K)
}

// Методы тоже могут иметь параметры-типы

// def remove[K](key: K)
